<!doctype html>

<html>

<head>
  <meta name="viewport" content="width=device-width initial-scale=1 maximum-scale=1 minimum-scale=1 user-scalable=0" />
  <title>CGI for Caddy</title>
  <style>
    body {
      max-width: 800px;
      font-family: sans-serif;
      padding: 1em;
    }
    
    h1,
    h2,
    h3 {
      color: #345;
    }
    
    .syntax {
      display: block;
      white-space: pre;
      font-family: monospace;
      background-color: #efe;
      border: 1px solid #474;
      margin: 1em 0;
      padding: 0.25em 1.5em;
    }
    
    .warning {
      background-color: #ffd;
      border: 1px solid #665;
      margin: 1em 0;
      padding: 0.25em 1.5em;
    }
    
    .key {
      color: #474;
    }
    
    .subkey {
      font-style: italic;
    }
    
    pre {
      color: #ddd;
      background-color: #444;
      margin: 1em 0;
      padding: 0.25em 0.5em;
      overflow-x: scroll;
    }
  </style>
</head>

<body>
<h1>CGI for Caddy</h1>

<p><a href="https://github.com/jung-kurt/caddy-cgi"><img src="https://img.shields.io/badge/project-Git_Hub-blue.svg" alt="Git Hub repository" /></a>
<a href="https://github.com/jung-kurt/"><img src="https://img.shields.io/badge/author-Kurt_Jung-blue.svg" alt="Kurt Jung" /></a>
<a href="https://raw.githubusercontent.com/jung-kurt/caddy-cgi/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT licensed" /></a>
<a href="https://travis-ci.org/jung-kurt/caddy-cgi"><img src="https://travis-ci.org/jung-kurt/caddy-cgi.svg?branch=master" alt="Build Status" /></a>
<a href="https://goreportcard.com/report/github.com/jung-kurt/caddy-cgi"><img src="https://goreportcard.com/badge/github.com/jung-kurt/caddy-cgi" alt="Report" /></a></p>

<p>This plugin lets you generate dynamic content on your website by means of
command line scripts. To collect information about the inbound HTTP request,
your script examines certain environment variables such as
<code>PATH_INFO</code> and <code>QUERY_STRING</code>. Then, to return a dynamically
generated web page to the client, your script simply writes content to standard
output. In the case of POST requests, your script reads additional inbound
content from standard input.</p>

<p>The advantage of CGI is that you do not need to fuss with server startup and
persistence, long term memory management, sockets, and crash recovery. Your
script is called when a request matches one of the patterns that you specify in
your Caddyfile. As soon as your script completes its response, it terminates.
This simplicity makes CGI a perfect complement to the straightforward operation
and configuration of Caddy. The benefits of Caddy, including HTTPS by default,
basic access authentication, and lots of middleware options extend easily to
your CGI scripts.</p>

<p>CGI has some disadvantages. For one, Caddy needs to start a new process for
each request. This can adversely impact performance and, if resources are
shared between CGI applications, may require the use of some interprocess
synchronization mechanism such as a file lock. Your server&rsquo;s responsiveness
could in some circumstances be affected, such as when your web server is hit
with very high demand, when your script&rsquo;s dependencies require a long startup,
or when concurrently running scripts take a long time to respond. However, in
many cases, such as using a pre-compiled CGI application like fossil or a Lua
script, the impact will generally be insignificant. Another restriction of CGI
is that scripts will be run with the same permissions as Caddy itself. This can
sometimes be less than ideal, for example when your script needs to read or
write files associated with a different owner.</p>

<h3>Security Considerations</h3>

<p>Serving dynamic content exposes your server to more potential threats than
serving static pages. There are a number of considerations of which you should
be aware when using CGI applications.</p>

<div class="warning"><p><strong>CGI scripts should be located outside of Caddy&rsquo;s document root.</strong>
Otherwise, an inadvertent misconfiguration could result in Caddy delivering
the script as an ordinary static resource. At best, this could merely
confuse the site visitor. At worst, it could expose sensitive internal
information that should not leave the server.</p></div>

<div class="warning"><p><strong>Mistrust the contents of <code>PATH_INFO</code>, <code>QUERY_STRING</code> and standard input.</strong>
Most of the environment variables available to your CGI program are
inherently safe because they originate with Caddy and cannot be modified by
external users. This is not the case with <code>PATH_INFO</code>, <code>QUERY_STRING</code> and,
in the case of POST actions, the contents of standard input. Be sure to
validate and sanitize all inbound content. If you use a CGI library or
framework to process your scripts, make sure you understand its
limitations.</p></div>

<h3>Errors</h3>

<p>An error in a CGI application is generally handled within the application
itself and reported in the headers it returns. Additionally, if the Caddy
<code>errors</code> directive is enabled, any content the application writes to its
standard error stream will be written to the error log. This can be useful to
diagnose problems with the execution of the CGI application.</p>

<h3>Application Modes</h3>

<p>Your CGI application can be executed directly or indirectly. In the direct
case, the application can be a compiled native executable or it can be a shell
script that contains as its first line a shebang that identifies the
interpreter to which the file&rsquo;s name should be passed. Caddy must have
permission to execute the application. On Posix systems this will mean making
sure the application&rsquo;s ownership and permission bits are set appropriately; on
Windows, this may involve properly setting up the filename extension
association.</p>

<p>In the indirect case, the name of the CGI script is passed to an interpreter
such as lua, perl or python.</p>

<h3>Basic Syntax</h3>

<p>The basic cgi directive lets you associate a single pattern with a particular
script. The directive can be repeated any reasonable number of times. Here is
the basic syntax:</p>

<div class="syntax"><p><span class="key">cgi</span> <span class="subkey">match exec [args&hellip;]</span></p></div>

<p>For example:</p>

<pre><code>cgi /report /usr/local/cgi-bin/report
</code></pre>

<p>When a request such as https://example.com/report or
https://example.com/report/weekly arrives, the cgi middleware will detect the
match and invoke the script named /usr/local/cgi-bin/report. Here, it is
assumed that the script is self-contained, for example a pre-compiled CGI
application or a shell script. Here is an example of a standalone script,
similar to one used in the cgi plugin&rsquo;s test suite:</p>

<pre><code>#!/bin/bash

printf "Content-type: text/plain\n\n"

printf "PATH_INFO    [%s]\n" $PATH_INFO
printf "QUERY_STRING [%s]\n" $QUERY_STRING

exit 0
</code></pre>

<p>The environment variables <code>PATH_INFO</code> and <code>QUERY_STRING</code> are populated and
passed to the script automatically. There are a number of other standard CGI
variables included that are described below. If you need to pass any special
environment variables or allow any environment variables that are part of
Caddy&rsquo;s process to pass to your script, you will need to use the advanced
directive syntax described below.</p>

<p>The values used for the script name and its arguments are subject to
placeholder replacement. In addition to the standard Caddy placeholders such as
<code>{method}</code> and <code>{host}</code>, the following placeholder substitutions are made:</p>

<ul>
<li><strong>{.}</strong> is replaced with Caddy&rsquo;s current working directory</li>
<li><strong>{match}</strong> is replaced with the portion of the request that satisfies the match directive</li>
<li><strong>{root}</strong> is replaced with Caddy&rsquo;s specified root directory</li>
</ul>


<p>You can include glob wildcards in your matches. Basically, an asterisk
represents a sequence of zero or more non-slash characters and a question mark
represents a single non-slash character. These wildcards can be used multiple
times in a match expression. See the documentation for <a href="https://golang.org/pkg/path/#Match">path/Match</a> in
the Go standard library for more details about glob matching. Here is an
example directive:</p>

<pre><code>cgi /report/*.lua /usr/bin/lua /usr/local/cgi-bin/{match}
</code></pre>

<p>In this case, the cgi middleware will match requests such as
https://example.com/report/weekly.lua and
https://example.com/report/report.lua/weekly but not
https://example.com/report.lua. The use of the asterisk expands to any
character sequence within a directory. For example, if the request</p>

<pre><code>https://report/weekly.lua/summary
</code></pre>

<p>is made, the following command is executed:</p>

<pre><code>/usr/bin/lua /usr/local/cgi-bin/report/weeky.lua
</code></pre>

<p>Note that the portion of the request that follows the match is not included.
That information is conveyed to the script by means of environment variables.
In this example, the Lua interpreter is invoked directly from Caddy, so the Lua
script does not need the shebang that would be needed in a standalone script.
This method facilitates the use of CGI on the Windows platform.</p>

<h3>Advanced Syntax</h3>

<p>In order to specify custom environment variables, pass along one or more
environment variables known to Caddy, or specify more than one match pattern
for a given rule, you will need to use the advanced directive syntax. That
looks like this:</p>

<div class="syntax"><p><span class="key">cgi</span> {
  <span class="key">match</span> <span class="subkey">match [match2&hellip;]</span>
  <span class="key">exec</span> <span class="subkey">script [args&hellip;]</span>
  <span class="key">env</span> <span class="subkey">key1=val1 [key2=val2&hellip;]</span>
  <span class="key">pass_env</span> <span class="subkey">key1 [key2&hellip;]</span>
}</p></div>

<p>For example,</p>

<pre><code>cgi {
    match /sample/*.php /sample/app/*.php
    exec /usr/local/cgi-bin/phpwrap /usr/local/cgi-bin{match}
    env DB=/usr/local/share/app/app.db SECRET=/usr/local/share/app/secret
    pass_env HOME UID
}
</code></pre>

<p>With the advanced syntax, the <code>exec</code> subdirective must appear exactly once. The
<code>match</code> subdirective must appear at least once. The <code>env</code> and <code>pass_env</code>
subdirectives can appear any reasonable number of times.</p>

<p>The values associated with environment variable keys are all subject to
placeholder substitution, just as with the script name and arguments.</p>

<p>If your CGI application runs properly at the command line but fails to run from
Caddy it is possible that certain environment variables may be missing. For
example, the ruby gem loader evidently requires the <code>HOME</code> environment variable
to be set; you can do this with the subdirective <code>pass_env HOME</code>.</p>

<h3>JSON web tokens</h3>

<p>If you protect your CGI application with the <a href="https://github.com/BTBurke/caddy-jwt">Caddy JWT</a> middleware, your
program will have access to the token&rsquo;s payload claims by means of environment
variables. For example, the following token claims</p>

<pre><code>{
    "sub": "1234567890",
    "user": "quixote",
    "admin": true,
}
</code></pre>

<p>will be available with the following environment variables</p>

<pre><code>HTTP_TOKEN_CLAIM_SUB=1234567890
HTTP_TOKEN_CLAIM_USER=quixote
HTTP_TOKEN_CLAIM_ADMIN=true
</code></pre>

<p>All values are conveyed as strings, so some conversion may be necessary in your
program. No placeholder substitutions are made on these values.</p>

<h3>Environment Variable Example</h3>

<p>In this example, the Caddyfile looks like this:</p>

<pre><code>192.168.1.2:8080
root /usr/local/www
cgi /show /usr/local/cgi-bin/report/gen
</code></pre>

<p>Note that a request for /show gets mapped to a script named
/usr/local/cgi-bin/report/gen. There is no need for any element of the script
name to match any element of the match pattern.</p>

<p>The contents of /usr/local/cgi-bin/report/gen are:</p>

<pre><code>#!/bin/bash

printf "Content-type: text/plain\n\n"

printf "example error message\n" &gt; /dev/stderr

if [ "POST" = "$REQUEST_METHOD" -a -n "$CONTENT_LENGTH" ]; then
  read -n "$CONTENT_LENGTH" POST_DATA
fi

printf "AUTH_TYPE         [%s]\n" $AUTH_TYPE
printf "CONTENT_LENGTH    [%s]\n" $CONTENT_LENGTH
printf "CONTENT_TYPE      [%s]\n" $CONTENT_TYPE
printf "GATEWAY_INTERFACE [%s]\n" $GATEWAY_INTERFACE
printf "PATH_INFO         [%s]\n" $PATH_INFO
printf "PATH_TRANSLATED   [%s]\n" $PATH_TRANSLATED
printf "POST_DATA         [%s]\n" $POST_DATA
printf "QUERY_STRING      [%s]\n" $QUERY_STRING
printf "REMOTE_ADDR       [%s]\n" $REMOTE_ADDR
printf "REMOTE_HOST       [%s]\n" $REMOTE_HOST
printf "REMOTE_IDENT      [%s]\n" $REMOTE_IDENT
printf "REMOTE_USER       [%s]\n" $REMOTE_USER
printf "REQUEST_METHOD    [%s]\n" $REQUEST_METHOD
printf "SCRIPT_EXEC       [%s]\n" $SCRIPT_EXEC
printf "SCRIPT_NAME       [%s]\n" $SCRIPT_NAME
printf "SERVER_NAME       [%s]\n" $SERVER_NAME
printf "SERVER_PORT       [%s]\n" $SERVER_PORT
printf "SERVER_PROTOCOL   [%s]\n" $SERVER_PROTOCOL
printf "SERVER_SOFTWARE   [%s]\n" $SERVER_SOFTWARE

exit 0
</code></pre>

<p>The purpose of this script is to show how request information gets communicated
to a CGI script. Note that POST data must be read from standard input. In this
particular case, posted data gets stored in the variable <code>POST_DATA</code>. Your
script may use a different method to read POST content. Secondly, the
<code>SCRIPT_EXEC</code> variable is not a CGI standard. It is provided by this middleware
and contains the entire command line, including all arguments, with which the
CGI script was executed.</p>

<p>When a browser requests</p>

<pre><code>http://192.168.1.2:8080/show/weekly?mode=summary
</code></pre>

<p>the response looks like</p>

<pre><code>AUTH_TYPE         []
CONTENT_LENGTH    []
CONTENT_TYPE      []
GATEWAY_INTERFACE [CGI/1.1]
PATH_INFO         [/weekly]
PATH_TRANSLATED   []
POST_DATA         []
QUERY_STRING      [mode=summary]
REMOTE_ADDR       [192.168.1.35]
REMOTE_HOST       [192.168.1.35]
REMOTE_IDENT      []
REMOTE_USER       []
REQUEST_METHOD    [GET]
SCRIPT_EXEC       [/usr/local/cgi-bin/report/gen]
SCRIPT_NAME       [/show]
SERVER_NAME       [192.168.1.2:8080]
SERVER_PORT       [8080]
SERVER_PROTOCOL   [HTTP/1.1]
SERVER_SOFTWARE   [go]
</code></pre>

<p>When a client makes a POST request, such as with the following command</p>

<pre><code>wget -O - -q --post-data="city=San%20Francisco" http://192.168.1.2:8080/show/weekly?mode=summary
</code></pre>

<p>the response looks the same except for the following lines:</p>

<pre><code>CONTENT_LENGTH    [20]
CONTENT_TYPE      [application/x-www-form-urlencoded]
POST_DATA         [city=San%20Francisco]
REQUEST_METHOD    [POST]
</code></pre>

<h3>Fossil Example</h3>

<p>The <a href="https://www.fossil-scm.org/">fossil</a> distributed software management tool is a native
executable that supports interaction as a CGI application. In this example,
/usr/bin/fossil is the executable and /home/quixote/projects.fossil is the
fossil repository. To configure Caddy to serve it, use a cgi directive
something like this in your Caddyfile:</p>

<pre><code>cgi /projects /usr/bin/fossil /usr/local/cgi-bin/projects
</code></pre>

<p>In your /usr/local/cgi-bin directory, make a file named projects with the
following single line:</p>

<pre><code>repository: /home/quixote/projects.fossil
</code></pre>

<p>The fossil documentation calls this a command file. When fossil is invoked
after a request to /projects, it examines the relevant environment variables
and responds as a CGI application. If you protect /projects with
<a href="https://caddyserver.com/docs/basicauth">basic HTTP authentication</a>, you may wish to enable the
<strong>Allow REMOTE_USER authentication</strong> option when setting up fossil. This lets
fossil dispense with its own authentication, assuming it has an account for
the user.</p>

<h3>Agedu Example</h3>

<p>The <a href="http://www.chiark.greenend.org.uk/~sgtatham/agedu/">agedu</a> utility can be used to identify unused files that are taking
up space on your storage media. Like fossil, it can be used in different modes
including CGI. First, use it from the command line to generate an index of a
directory, for example</p>

<pre><code>agedu --file /home/quixote/agedu.dat --scan /home/quixote
</code></pre>

<p>In your Caddyfile, include a directive that references the generated index:</p>

<pre><code>cgi /agedu /usr/local/bin/agedu --cgi --file /home/quixote/agedu.dat
</code></pre>

<p>You will want to protect the /agedu resource with some sort of access control,
for example <a href="https://caddyserver.com/docs/basicauth">HTTP Basic Authentication</a>.</p>

<h3>Go Source Example</h3>

<p>This small example demonstrates how to write a CGI program in Go. The use of a
bytes.Buffer makes it easy to report the content length in the CGI header.</p>

<pre><code>package main

import (
    "bytes"
    "fmt"
    "os"
    "time"
)

func main() {
    var buf bytes.Buffer

    fmt.Fprintf(&amp;buf, "Server time at %s is %s\n",
        os.Getenv("SERVER_NAME"), time.Now().Format(time.RFC1123))
    fmt.Println("Content-type: text/plain")
    fmt.Printf("Content-Length: %d\n\n", buf.Len())
    buf.WriteTo(os.Stdout)
}
</code></pre>

<p>When this program is compiled and installed as /usr/local/bin/servertime, the
following directive in your Caddy file will make it available:</p>

<pre><code>cgi /servertime /usr/local/bin/servertime
</code></pre>

<h3>Cgit Example</h3>

<p>The <a href="https://git.zx2c4.com/cgit/about/">cgit</a> application provides an attractive and useful web interface to
git repositories. Here is how to run it with Caddy. After compiling cgit, you
can place the executable somewhere out of Caddy&rsquo;s document root. In this
example, it is located in /usr/local/cgi-bin.</p>

<p>A sample configuration file is included in the project&rsquo;s cgitrc.5.txt file. You
can use it as a starting point for your configuration. The default location for
this file is /etc/cgitrc but in this example the location
/home/quixote/caddy/cgitrc. Note that changing the location of this file from
its default will necessitate the inclusion of the environment variable
CGIT_CONFIG in the Caddyfile cgi directive.</p>

<p>When you edit the repository stanzas in this file, be sure each repo.path item
refers to the .git directory within a working checkout. Here is an example
stanza:</p>

<pre><code>repo.url=caddy-cgi
repo.path=/home/quixote/go/src/github.com/jung-kurt/caddy-cgi/.git
repo.desc=CGI for Caddy
repo.owner=jung-kurt
repo.readme=/home/quixote/go/src/github.com/jung-kurt/caddy-cgi/README.md
</code></pre>

<p>Also, you will likely want to change cgit&rsquo;s cache directory from its default
in /var/cache (generally accessible only to root) to a location writeable by
Caddy. In this example, cgitrc contains the line</p>

<pre><code>cache-root=/home/quixote/.cache/cgit
</code></pre>

<p>You may need to create the cgit subdirectory.</p>

<p>There are some static cgit resources (namely, cgit.css, favicon.ico, and
cgit.png) that will be accessed from Caddy&rsquo;s document tree. For this example,
these files are placed in a directory named cgit-resource. The following lines
are part of the cgitrc file:</p>

<pre><code>css=/cgit-resource/cgit.css
favicon=/cgit-resource/favicon.ico
logo=/cgit-resource/cgit.png
</code></pre>

<p>Additionally, you will likely need to tweak the various file viewer filters
such source-filter and about-filter based on your system.</p>

<p>The following Caddyfile directive will allow you to access the cgit application
at /cgit:</p>

<pre><code>cgi {
    match /cgit
    exec /usr/local/cgi-bin/cgit
    env CGIT_CONFIG=/home/quixote/caddy/cgitrc
}
</code></pre>

<h3>PHP Example</h3>

<p>Feeling reckless? You can run <a href="http://php.net/">PHP</a> in CGI mode. In general,
<a href="https://caddyserver.com/docs/fastcgi">FastCGI</a> is the preferred method to run PHP if your application has
many pages or a fair amount of database activity. But for small PHP programs
that are seldom used, CGI can work fine. You&rsquo;ll need the php-cgi interpreter
for your platform. This may involve downloading the executable or downloading
and then compiling the source code. For this example, assume the interpreter is
installed as /usr/local/bin/php-cgi. Additionally, because of the way PHP
operates in CGI mode, you will need an intermediate script. This one works in
Posix environments:</p>

<pre><code>#!/bin/bash

REDIRECT_STATUS=1 SCRIPT_FILENAME="${1}" /usr/local/bin/php-cgi -c /home/quixote/.config/php/php-cgi.ini
</code></pre>

<p>This script can be reused for multiple cgi directives. In this example, it is
installed as /usr/local/cgi-bin/phpwrap. The argument following -c is your
initialization file for PHP. In this example, it is named
/home/quixote/.config/php/php-cgi.ini.</p>

<p>Two PHP files will be used for this example. The first,
/usr/local/cgi-bin/sample/min.php, looks like this:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;PHP Sample&lt;/title&gt;
    &lt;style&gt;
      form span {
        font: 15px sans-serif;
        display: inline-block;
        width: 8em;
        text-align: right;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form action="action.php" method="post"&gt;
      &lt;p&gt;&lt;span&gt;Name&lt;/span&gt; &lt;input type="text" name="name" /&gt;&lt;/p&gt;
      &lt;p&gt;&lt;span&gt;Number&lt;/span&gt; &lt;input type="text" name="number" /&gt;&lt;/p&gt;
      &lt;p&gt;&lt;span&gt;Day&lt;/span&gt; &lt;input type="text" name="day"
        value="&lt;?php echo(date("l", time())); ?&gt;" /&gt;&lt;/p&gt;
      &lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt; &lt;input type="submit" /&gt;&lt;/p&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>The second, /usr/local/cgi-bin/sample/action.php, follows:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;PHP Sample&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Name is &lt;strong&gt;&lt;?php echo htmlspecialchars($_POST['name']); ?&gt;&lt;/strong&gt;.&lt;/p&gt;
    &lt;p&gt;Number is &lt;strong&gt;&lt;?php echo (int)$_POST['number']; ?&gt;&lt;/strong&gt;.&lt;/p&gt;
    &lt;p&gt;Day is &lt;strong&gt;&lt;?php echo htmlspecialchars($_POST['day']); ?&gt;&lt;/strong&gt;.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>The following directive in your Caddyfile will make the application available
at sample/min.php:</p>

<pre><code>cgi /sample/*.php /usr/local/cgi-bin/phpwrap /usr/local/cgi-bin{match}
</code></pre>
	</body>

</html>
